#!/bin/bash

# Copyright â“’ 2016 Mattias Bengtsson
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with This program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Mattias Bengtsson <mattias.jc.bengtsson@gmail.com>

_subcommand=$(basename "${0}")
_subcommand=${_subcommand/git-/}

function _wip {
    [ "${_subcommand}" == "wip" ]
}

function _local {
    [ "${_subcommand}" == "local" ]
}

function _help-flag {
    [[ " ${*} " == *" --help "* ]] || [[ " ${*} " == *" -h "* ]]
}

function _select-commit {
    local IFS=$'\n'
    local _commits

    mapfile -t _commits < <(git --no-pager "${_subcommand}" log --oneline)

    if command -v fzf >/dev/null; then
        printf "%s\n" "${_commits[@]}" \
            | fzf --ansi --height $(( ${#_commits[@]} + 2))
    else
        select commit in "${_commits[@]}"; do
            echo "${commit}"
            break
        done
    fi | cut -f1 -d" "
}

function autosquash {
    if _help-flag "${@}"; then
        cat <<EOM
Usage: git ${_subcommand} autosquash [rebase-flags]

Short-hand for:
  EDITOR=true git rebase -i --autosquash [rebase-flags] "\$(git ${_subcommand} rebase-point)"
EOM
    else
        local _rp
        if _rp="$(rebase-point)"; then
            GIT_SEQUENCE_EDITOR=true git rebase -i --autosquash "${@}" "${_rp}"
        fi
    fi
}

function fixup {
    if _help-flag "${@}"; then
        echo "Usage: git ${_subcommand} fixup [commit-flags]"
        echo
        echo "Add a fixup commit to a previous commit."
    else
        local commit _rp
        if _rp="$(rebase-point)"; then
            commit="$(_select-commit "${_rp}")"
            git commit "${@}" --fixup="${commit}"
        fi
    fi
}

function for-all {
    if _help-flag "${@}"; then
        cat <<EOM
Usage: git ${_subcommand} foreach <COMMAND>

Run <COMMAND> over all commits, stopping in case of failure.
git rebase -x <COMMAND> "\$(git ${_subcommand} rebase-point)"
EOM

    else
        local _rp
        if _rp="$(rebase-point)"; then
            git rebase -x "${@}" "${_rp}"
        fi
    fi
}

function log {
    if _help-flag "${@}"; then
        cat <<EOM
Usage: git ${_subcommand} log [log-flags]

Short-hand for:
  git log [log-flags] "\$(git ${_subcommand} rebase-point)"..
EOM
    else
        local _rp
        if _rp="$(rebase-point)"; then
            git log "${@}" "${_rp}"..
        fi
    fi
}

function reapply {
    if _help-flag "${@}"; then
        cat <<EOM
Usage: git ${_subcommand} reapply [rebase-flags]

Short-hand for:
  git rebase -i [rebase-flags] "\$(git ${_subcommand} rebase-point)"
EOM
    else
        local _rp
        if _rp="$(rebase-point)"; then
            git rebase -i "${@}" "${_rp}"
        fi
    fi
}

function rebase-point {
    if _wip; then
        for ref in $(git rev-list --parents "HEAD"); do
            if [ "$(git branch --contains "${ref}" | wc -l)" -gt 1 ]; then
                echo "${ref}"
                exit 0
            fi
        done
    elif _local; then
        git merge-base HEAD "@{upstream}" && exit 0
    fi

    echo "No suitable rebase-point found!" >> /dev/stderr
    exit 1
}

function squash {
    if _help-flag "${@}"; then
        cat <<EOM
Usage: git ${_subcommand} squash [commit-flags]

Add a squash commit to a previous commit.
EOM
    else
        local commit _rp
        if _rp="$(rebase-point)"; then
            commit="$(_select-commit "${_rp}")"
            git commit "${@}" --squash="${commit}"
        fi
    fi
}

arg="${1}"
shift
case "${arg}" in
    autosquash)
        autosquash "${@}"
        ;;
    fixup)
        fixup "${@}"
        ;;
    for-all)
        for-all "${@}"
        ;;
    log)
        log "${@}"
        ;;
    reapply)
        reapply "${@}"
        ;;
    rebase-point)
        rebase-point "${@}"
        ;;
    squash)
        squash "${@}"
        ;;
    *)
        declare -a strings
        if _wip; then
            strings=( "since the latest branch-point"
                      "the commits unique to this branch"
                      "commit unique for this branch" )
        else
            strings=( "not yet pushed upstream"
                      "your local, not yet pushed, commits"
                      "local, not yet pushed, commit" )
        fi
        cat <<EOM
Usage: git ${_subcommand} [command] [<option>]

  git ${_subcommand} helps you modify commits ${strings[0]}
  All commands work only on ${strings[1]}

Commands:
  autosquash          Automatically squash all squash! and fixup! commits
  for-all             Run a command over all commits, stopping in case of
                      failure.
  fixup               Add a fixup commit to a previous commit.
  log                 Show commit logs
  reapply             Reapply all commits using an interactive rebase
  rebase-point        Get the parent of the first ${strings[2]}
  squash              Add a squash commit to a previous commit.
EOM
        exit 2
        ;;
esac
